<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Animated GIFs at {method_name} Coordinates</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1800px; /* Increased from 1200px */
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            border-radius: 8px;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .plot-container {
            position: relative;
            margin: 20px auto;
            border: 1px solid #ddd;
            background-color: #fff;
            overflow: hidden;
            width: 1600px; /* Increased from 1000px */
            height: 1200px; /* Increased from 800px */
        }
        .point {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .gif-container {
            position: absolute;
            border: 2px solid #333;
            background-color: white;
            border-radius: 4px;
            overflow: hidden;
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer; /* Show pointer cursor to indicate clickability */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .gif-container:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border-color: #4CAF50;
        }
        .gif-container::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.7);
            color: white;
            font-size: 1px;
            padding: 2px 4px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .gif-container:hover::after {
            opacity: 0.5;
        }
        .gif-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .controls {
            margin-top: 10px;
            text-align: center;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls button {
            padding: 8px 15px;
            margin: 0 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .controls button:hover {
            background-color: #45a049;
        }
        .gif-size-slider {
            width: 200px;
            margin: 0 10px;
            vertical-align: middle;
        }
        .control-group {
            display: inline-block;
            margin: 0 15px;
            vertical-align: middle;
        }
        .control-label {
            font-weight: bold;
            margin-right: 10px;
        }
        .dragging {
            opacity: 0.8;
            z-index: 1000;
        }
        .cluster-filter {
            margin-top: 10px;
            text-align: center;
        }
        .cluster-checkbox {
            margin-right: 5px;
        }
        .cluster-label {
            margin-right: 15px;
            user-select: none;
        }
        #debug-message {
            padding: 10px;
            margin: 10px 0;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .frame-slider {
            width: 300px;
            margin: 0 10px;
            vertical-align: middle;
        }  
        .frame-control {
            margin-top: 10px;
            padding: 8px;
            background-color: #e8f7e8;
            border-radius: 4px;
            border: 1px solid #4CAF50;
        }
    </style>
    <script>
        // Function to generate WebKnossos URL based on central coordinates and bbox number
        function generateWebknossosUrl(centralCoordX, centralCoordY, centralCoordZ, bboxName) {
            // Extract bbox number from bbox name (e.g., "bbox1" -> 1)
            const bboxNum = parseInt(bboxName.replace('bbox', ''));
            
            if (isNaN(bboxNum)) {
                console.error("Invalid bbox name format:", bboxName);
                return null;
            }
            
            let x1, y1, z1;
            
            // Calculate bbox coordinates based on central coordinates (adapted from WebknossosUrl.py)
            switch(bboxNum) {
                case 1:
                    x1 = 14219 - 100 + centralCoordX;
                    y1 = 10792 - 100 + centralCoordY;
                    z1 = 15134 - 100 + centralCoordZ;
                    break;
                case 2:
                    x1 = 18544 + centralCoordX;
                    y1 = 5409 + centralCoordY;
                    z1 = 4374 + centralCoordZ;
                    break;
                case 3:
                    x1 = 14783 - 100 + centralCoordX;
                    y1 = 3707 - 100 + centralCoordY;
                    z1 = 4316 - 100 + centralCoordZ;
                    break;
                case 4:
                    x1 = 15813 - 100 + centralCoordX;
                    y1 = 7009 - 100 + centralCoordY;
                    z1 = 10408 - 100 + centralCoordZ;
                    break;
                case 5:
                    x1 = 1782 - 100 + centralCoordX;
                    y1 = 8962 - 100 + centralCoordY;
                    z1 = 8309 - 100 + centralCoordZ;
                    break;
                case 6:
                    x1 = 16700 - 100 + centralCoordX;
                    y1 = 11200 - 100 + centralCoordY;
                    z1 = 15573 - 100 + centralCoordZ;
                    break;
                case 7:
                    x1 = 12340 + centralCoordX;
                    y1 = 9416 + centralCoordY;
                    z1 = 16439 + centralCoordZ;
                    break;
                default:
                    console.error("Unknown bbox number:", bboxNum);
                    return null;
            }
            
            // Generate the final URL
            return `https://webknossos.brain.mpg.de/annotations/67bcfa0301000006202da79c#${x1},${y1},${z1},0,0.905,1506`;
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>{method_name} Visualization with Animated GIFs</h1>
        
        <div id="debug-message"></div>
        
        <div class="controls">
            <div class="control-group">
                <button id="toggle-gifs">Hide GIFs</button>
            </div>
            
            <div class="control-group">
                <span class="control-label">GIF Size:</span>
                <input type="range" min="20" max="200" value="50" id="gif-size-slider" class="gif-size-slider">
                <span id="size-value">50px</span>
                <button id="resize-gifs">Apply Size</button>
            </div>
            
            <div class="control-group">
                <span class="control-label">Number of GIFs:</span>
                <input type="range" min="1" max="{len(samples_with_gifs)}" value="{len(samples_with_gifs)}" id="num-gifs-slider" class="gif-size-slider">
                <span id="num-gifs-value">{len(samples_with_gifs)}</span>
                <button id="apply-num-gifs">Apply</button>
            </div>
            
            <div class="control-group">
                <button id="reset-positions">Reset Positions</button>
            </div>
            
            <div class="control-group frame-control">
                <span class="control-label">Frame Control:</span>
                <input type="range" min="0" max="80" value="0" id="frame-slider" class="frame-slider">
                <span id="frame-value">0</span>
                <button id="play-pause">Play/Pause</button>
                <button id="show-max-cleft">Show Max Cleft Slices</button>
            </div>
        </div>
        
        <div class="cluster-filter" id="cluster-filter">
            <span class="control-label">Filter by Cluster:</span>
            <!-- Cluster checkboxes will be added here by JavaScript -->
        </div>
        
        <div class="plot-container" id="plot">
            <!-- Background points will be added here -->
            <!-- GIFs will be added here -->
        </div>
    </div>
    
    <script>
        // Initialize debug element
        const debugMessage = document.getElementById('debug-message');
        function log(message) {
            debugMessage.innerHTML += message + '<br>';
            console.log(message);
        }
        
        // log("Script started");
        
        // Define the UMAP bounds
        const xMin = {x_min};
        const xMax = {x_max};
        const yMin = {y_min};
        const yMax = {y_max};
        
        // Track visibility state
        let gifsVisible = true;
        
        // log(`Coordinate bounds: X: ${xMin} to ${xMax}, Y: ${yMin} to ${yMax}`);
        
        // Function to map UMAP coordinates to plot coordinates
        function mapToPlot(x, y, width, height) {
            const plotX = ((x - xMin) / (xMax - xMin)) * width;
            // Invert y-axis (UMAP coordinates increase upward, plot coordinates increase downward)
            const plotY = height - ((y - yMin) / (yMax - yMin)) * height;
            return [plotX, plotY];
        }
        
        // Get the plot container
        const plot = document.getElementById('plot');
        const plotWidth = plot.clientWidth;
        const plotHeight = plot.clientHeight;
        
        // log(`Plot dimensions: ${plotWidth}x${plotHeight}`);
        
        // Store original positions of GIFs for reset functionality
        let originalPositions = {};
        try {
            originalPositions = {originalPositions};
            // log(`Loaded original positions data with ${Object.keys(originalPositions).length} items`);
        } catch (e) {
            // log(`Error loading original positions: ${e.message}`);
        }
        
        // Store all GIF data with cluster information
        const allGifData = [];
        
        // Store frames data for all GIFs
        const allFramesData = {};
        try {
            // Parse frames data string to JavaScript object
            const framesStr = `{frames_content}`;
            // log(`Loading frames data: ${framesStr.substring(0, 100)}...`);
            
            // Check if we have valid JSON
            if (framesStr && framesStr !== "{}" && framesStr.length > 2) {
                const framesData = JSON.parse(framesStr);
                Object.assign(allFramesData, framesData);
                // log(`Loaded frames data for ${Object.keys(allFramesData).length} GIFs`);
            } else {
                // log("No frames data available");
            }
        } catch(e) {
            // log(`Error loading frames data: ${e.message}`);
        }
        
        // Variable to track play/pause state
        let isPlaying = false;
        let animationInterval = null;
        let currentFrame = 0;
        
        // Function to update the frame display for all GIFs
        function updateFrameDisplay(frameIndex) {
            // Update all visible gif containers
            document.querySelectorAll('.gif-container.has-frames').forEach(container => {
                const id = container.dataset.id;
                if (id && allFramesData[id] && allFramesData[id].length > 0) {
                    // Make sure we don't exceed the frame count for this GIF
                    const actualFrame = Math.min(frameIndex, allFramesData[id].length - 1);
                    const frameImg = container.querySelector('img');
                    if (frameImg) {
                        frameImg.src = `data:image/png;base64,${allFramesData[id][actualFrame]}`;
                    }
                }
            });
            
            // Update the frame value display
            document.getElementById('frame-value').textContent = frameIndex;
        }
        
        // Function to show max cleft slices for each GIF
        function showMaxCleftSlices() {
            pauseFrames(); // Stop any animation
            
            console.log("Show Max Cleft Slices button clicked");
            console.log("allGifData:", allGifData);
            
            // Count how many GIFs have max_slices data
            let gifsWithMaxSlices = 0;
            allGifData.forEach(gif => {
                if (gif.max_slices) {
                    gifsWithMaxSlices++;
                    console.log(`GIF ${gif.id} has max_slices:`, gif.max_slices);
                }
            });
            console.log(`Found ${gifsWithMaxSlices} GIFs with max_slices data`);
            
            // Update all visible gif containers
            const containers = document.querySelectorAll('.gif-container.has-frames');
            console.log(`Found ${containers.length} GIF containers with frames`);
            
            containers.forEach(container => {
                const id = container.dataset.id;
                console.log(`Processing container with ID: ${id}`);
                
                // Find the gif data with matching ID
                const gifData = allGifData.find(gif => gif.id.toString() === id);
                
                if (gifData) {
                    console.log(`Found matching gifData for ID ${id}`);
                    console.log(`gifData.max_slices:`, gifData.max_slices);
                    
                    if (gifData.max_slices) {
                        // Use max_z_slice as the default best slice to show
                        const sliceIndex = gifData.max_slices.max_z_slice;
                        console.log(`max_z_slice for GIF ${id}: ${sliceIndex}`);
                        
                        if (allFramesData[id] && allFramesData[id].length > 0) {
                            console.log(`Found frames data for GIF ${id}, number of frames: ${allFramesData[id].length}`);
                            
                            // Make sure we don't exceed the frame count for this GIF
                            const actualFrame = Math.min(sliceIndex, allFramesData[id].length - 1);
                            
                            // Update display to show the max cleft slice
                            const frameImg = container.querySelector('img');
                            if (frameImg) {
                                console.log(`Updating GIF ${id} to show frame ${actualFrame}`);
                                frameImg.src = `data:image/png;base64,${allFramesData[id][actualFrame]}`;
                                
                                // Update the frame slider to reflect this position
                                const frameSlider = document.getElementById('frame-slider');
                                if (frameSlider) {
                                    frameSlider.value = actualFrame;
                                    document.getElementById('frame-value').textContent = actualFrame;
                                }
                                
                                console.log(`Updated GIF ${id} to show max cleft slice at frame ${actualFrame}`);
                            } else {
                                console.log(`No img element found in container for GIF ${id}`);
                            }
                        } else {
                            console.log(`No frames data for GIF ${id}`);
                        }
                    } else {
                        console.log(`GIF ${id} has no max_slices data`);
                    }
                } else {
                    console.log(`No matching gifData found for ID ${id}`);
                }
            });
        }
        
        // Function to handle playing animation
        function playFrames() {
            if (animationInterval) {
                clearInterval(animationInterval);
            }
            
            animationInterval = setInterval(() => {
                // Get the max frame count among all GIFs
                let maxFrames = 80; // Default value
                Object.values(allFramesData).forEach(frames => {
                    if (frames && frames.length > maxFrames) {
                        maxFrames = frames.length;
                    }
                });
                
                // Update frame slider max value
                const frameSlider = document.getElementById('frame-slider');
                if (frameSlider) {
                    frameSlider.max = maxFrames - 1;
                
                    // Increment current frame and loop if needed
                    currentFrame = (currentFrame + 1) % maxFrames;
                
                    // Update frame slider position
                    frameSlider.value = currentFrame;
                }
                
                // Update all GIFs to show this frame
                updateFrameDisplay(currentFrame);
            }, 100); // 10 FPS
        }
        
        // Function to stop playing animation
        function pauseFrames() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }
        
        // Add background points for all samples
        function addBackgroundPoints() {
            // log("Adding background points...");
            
            // Samples from features_df
            let samples = [];
            try {
                samples = [
                    {points_content}
                ];
                // log(`Found ${samples.length} background points to add`);
            } catch (e) {
                // log(`Error loading background points: ${e.message}`);
                return;
            }
            
            // Add points to the plot
            let pointsAdded = 0;
            samples.forEach(sample => {
                try {
                    const [plotX, plotY] = mapToPlot(sample.x, sample.y, plotWidth, plotHeight);
                    
                    const pointElem = document.createElement('div');
                    pointElem.className = 'point';
                    pointElem.style.left = `${plotX}px`;
                    pointElem.style.top = `${plotY}px`;
                    pointElem.style.backgroundColor = sample.color;
                    
                    // Make points with GIFs larger
                    if (sample.hasGif) {
                        pointElem.style.width = '10px';
                        pointElem.style.height = '10px';
                        pointElem.style.border = '2px solid black';
                        pointElem.style.zIndex = '5';
                    }
                    
                    plot.appendChild(pointElem);
                    pointsAdded++;
                } catch (e) {
                    log(`Error adding point: ${e.message}`);
                }
            });
            
            // log(`Successfully added ${pointsAdded} background points`);
        }
        
        // Function to add GIFs
        function addGifs() {
            try {
                console.log("Starting addGifs function...");
                
                // Debug the gifs_content structure
                const gifsContentStr = `{gifs_content}`;
                console.log("Raw GIFs content string length:", gifsContentStr.length);
                console.log("GIFs content sample:", gifsContentStr.substring(0, 200) + "...");
                
                // Add each GIF at its position on the plot
                const gifs = [
                    {gifs_content}
                ];
                
                console.log(`Found ${gifs.length} GIFs to add. First GIF:`, gifs.length > 0 ? gifs[0] : "No GIFs");
                
                // Store the GIF data for later reference
                gifs.forEach(gif => {
                    // Parse max_slices data if it exists and is a string
                    if (gif.max_slices) {
                        console.log(`Found max_slices for GIF ${gif.id}:`, gif.max_slices);
                        if (typeof gif.max_slices === 'string' && gif.max_slices !== 'null') {
                            try {
                                console.log(`Parsing max_slices string for GIF ${gif.id}: ${gif.max_slices}`);
                                gif.max_slices = JSON.parse(gif.max_slices);
                                console.log(`Successfully parsed max_slices for GIF ${gif.id}:`, gif.max_slices);
                            } catch (e) {
                                console.error(`Error parsing max_slices for GIF ${gif.id}: ${e}`);
                                gif.max_slices = null;
                            }
                        } else if (gif.max_slices === 'null' || gif.max_slices === null) {
                            console.log(`GIF ${gif.id} has null max_slices`);
                            gif.max_slices = null;
                        } else {
                            console.log(`GIF ${gif.id} has max_slices that is not a string:`, typeof gif.max_slices);
                        }
                    } else {
                        console.log(`No max_slices found for GIF ${gif.id}`);
                    }
                    
                    allGifData.push(gif);
                });
                
                // Tracking placed rectangles to prevent overlap
                const placedRectangles = [];
                const gifSize = 50; // Default size
                
                // Initialize container for tracking all GIF containers
                window.gifContainers = [];
                
                // Initially add all GIFs (or first 20 if there are many)
                const initialGifCount = Math.min(20, gifs.length);
                for (let i = 0; i < initialGifCount; i++) {
                    const container = addGifToPlot(gifs[i], i, placedRectangles, gifSize);
                    if (container) {
                        console.log(`Added GIF ${gifs[i].id} successfully`);
                    }
                }
                
                console.log(`Added ${initialGifCount} GIFs initially`);
                console.log(`Total GIF containers: ${window.gifContainers.length}`);
                
                // Make sure the toggle button has the correct initial state
                const toggleButton = document.getElementById('toggle-gifs');
                toggleButton.textContent = 'Hide GIFs';
                
                // Create cluster filters after adding GIFs
                createClusterFilter();
            } catch (e) {
                log(`Error adding GIFs: ${e.message}`);
                console.error("Stack trace:", e.stack);
            }
        }
        
        // Function to add a single GIF to the plot
        function addGifToPlot(sample, index, placedRectangles, gifSize) {
            try {
                const [plotX, plotY] = mapToPlot(sample.x, sample.y, plotWidth, plotHeight);
                
                // Use original position if available
                let posX = plotX;
                let posY = plotY;
                
                if (originalPositions[sample.id]) {
                    posX = originalPositions[sample.id].x;
                    posY = originalPositions[sample.id].y;
                } else {
                    // Find non-overlapping position if no original position
                    const position = findNonOverlappingPosition(plotX, plotY, placedRectangles, gifSize);
                    
                    // Skip if no valid position found
                    if (!position) {
                        console.log(`Skipping GIF ${sample.id} - couldn't find non-overlapping position`);
                        return null;
                    }
                    
                    posX = position.x;
                    posY = position.y;
                    
                    // Add rectangle to tracking
                    placedRectangles.push(position.rect);
                }
                
                // Create GIF container
                const gifContainer = document.createElement('div');
                gifContainer.className = 'gif-container';
                if (sample.hasFrames) {
                    gifContainer.classList.add('has-frames');
                }
                gifContainer.id = `gif-${sample.id}`;
                gifContainer.dataset.id = sample.id;
                gifContainer.dataset.index = index;
                gifContainer.dataset.cluster = sample.cluster;
                gifContainer.dataset.bbox = sample.bbox;
                
                // Set position and size
                gifContainer.style.left = `${posX}px`;
                gifContainer.style.top = `${posY}px`;
                gifContainer.style.width = `${gifSize}px`;
                gifContainer.style.height = `${gifSize}px`;
                gifContainer.style.display = 'block'; // Make sure GIFs are visible by default
                
                // Add coordinates for WebKnossos
                gifContainer.dataset.centralCoord1 = sample.central_coord_1 || 0;
                gifContainer.dataset.centralCoord2 = sample.central_coord_2 || 0;
                gifContainer.dataset.centralCoord3 = sample.central_coord_3 || 0;
                
                // Add max slices data if available
                if (sample.max_slices) {
                    gifContainer.dataset.maxSlices = JSON.stringify(sample.max_slices);
                }
                
                // Create image
                const gifImg = document.createElement('img');
                gifImg.src = `data:image/gif;base64,${sample.gifData}`;
                gifImg.alt = `Sample ${sample.id}`;
                
                // Add click handler for WebKnossos
                gifContainer.addEventListener('click', (e) => {
                    // Skip if was dragging
                    if (gifContainer.dataset.wasDragging === 'true') {
                        return;
                    }
                    
                    // Generate URL
                    const centralCoordX = parseInt(gifContainer.dataset.centralCoord1);
                    const centralCoordY = parseInt(gifContainer.dataset.centralCoord2);
                    const centralCoordZ = parseInt(gifContainer.dataset.centralCoord3);
                    const bboxName = gifContainer.dataset.bbox;
                    
                    if (centralCoordX && centralCoordY && centralCoordZ && bboxName) {
                        const url = generateWebknossosUrl(centralCoordX, centralCoordY, centralCoordZ, bboxName);
                        if (url) {
                            gifContainer.style.borderColor = '#4CAF50';
                            setTimeout(() => {
                                window.open(url, '_blank');
                            }, 150);
                        }
                    }
                });
                
                // Add image to container
                gifContainer.appendChild(gifImg);
                
                // Make draggable
                makeDraggable(gifContainer);
                
                // Add to plot
                plot.appendChild(gifContainer);
                
                // Add to global tracking
                window.gifContainers.push(gifContainer);
                
                return gifContainer;
            } catch (e) {
                console.error(`Error adding GIF ${sample.id}: ${e}`);
                return null;
            }
        }
        
        // Function to find a non-overlapping position
        function findNonOverlappingPosition(baseX, baseY, existingRects, gifSize) {
            // Check if the original position works
            const halfSize = gifSize / 2;
            const rect = {
                left: baseX - halfSize,
                right: baseX + halfSize,
                top: baseY - halfSize,
                bottom: baseY + halfSize
            };
            
            // Check for overlap with existing rectangles
            let hasOverlap = false;
            for (const existingRect of existingRects) {
                if (doRectanglesOverlap(rect, existingRect)) {
                    hasOverlap = true;
                    break;
                }
            }
            
            // If no overlap, use original position
            if (!hasOverlap) {
                return { x: baseX, y: baseY, rect: rect };
            }
            
            // Try positions in an expanding spiral
            const directions = [
                { x: 1, y: 0 },   // right
                { x: 0, y: 1 },   // down
                { x: -1, y: 0 },  // left
                { x: 0, y: -1 }   // up
            ];
            
            // Try up to 50px in each direction
            const maxDistance = 50;
            
            for (let distance = 5; distance <= maxDistance; distance += 5) {
                for (const dir of directions) {
                    const shiftedX = baseX + (dir.x * distance);
                    const shiftedY = baseY + (dir.y * distance);
                    
                    // Skip if out of bounds
                    if (shiftedX - halfSize < 0 || shiftedX + halfSize > plotWidth ||
                        shiftedY - halfSize < 0 || shiftedY + halfSize > plotHeight) {
                        continue;
                    }
                    
                    // Check this position
                    const shiftedRect = {
                        left: shiftedX - halfSize,
                        right: shiftedX + halfSize,
                        top: shiftedY - halfSize,
                        bottom: shiftedY + halfSize
                    };
                    
                    // Check for overlap
                    let shiftedOverlap = false;
                    for (const existingRect of existingRects) {
                        if (doRectanglesOverlap(shiftedRect, existingRect)) {
                            shiftedOverlap = true;
                            break;
                        }
                    }
                    
                    // Use this position if no overlap
                    if (!shiftedOverlap) {
                        return { x: shiftedX, y: shiftedY, rect: shiftedRect };
                    }
                }
            }
            
            // No non-overlapping position found
            return null;
        }
        
        // Create cluster filter checkboxes
        function createClusterFilter() {
            const clusterFilter = document.getElementById('cluster-filter');
            const clusters = new Set();
            
            // Get unique clusters
            allGifData.forEach(sample => {
                if (sample['cluster'] !== 'N/A') {
                    clusters.add(sample['cluster']);
                }
            });
            
            // Create a checkbox for each cluster
            clusters.forEach(cluster => {
                const label = document.createElement('label');
                label.className = 'cluster-label';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'cluster-checkbox';
                checkbox.value = cluster;
                checkbox.checked = true;
                checkbox.id = `cluster-${cluster}`;
                
                checkbox.addEventListener('change', updateVisibleGifs);
                
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(`Cluster ${cluster}`));
                
                clusterFilter.appendChild(label);
            });
            
            // Add "Select All" and "Deselect All" buttons
            const selectAllBtn = document.createElement('button');
            selectAllBtn.textContent = 'Select All';
            selectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('.cluster-checkbox').forEach(cb => {
                    cb.checked = true;
                });
                updateVisibleGifs();
            });
            
            const deselectAllBtn = document.createElement('button');
            deselectAllBtn.textContent = 'Deselect All';
            deselectAllBtn.addEventListener('click', () => {
                document.querySelectorAll('.cluster-checkbox').forEach(cb => {
                    cb.checked = false;
                });
                updateVisibleGifs();
            });
            
            clusterFilter.appendChild(document.createElement('br'));
            clusterFilter.appendChild(selectAllBtn);
            clusterFilter.appendChild(deselectAllBtn);
        }
        
        // Update visible GIFs based on filters
        function updateVisibleGifs() {
            console.log("Updating visible GIFs...");
            
            // Get selected clusters
            const selectedClusters = [];
            document.querySelectorAll('.cluster-checkbox:checked').forEach(cb => {
                selectedClusters.push(cb.value);
            });
            console.log("Selected clusters:", selectedClusters);
            
            // Get max number of GIFs to show
            const maxGifs = parseInt(document.getElementById('num-gifs-slider').value);
            console.log("Max GIFs to show:", maxGifs);
            
            // Count how many GIFs we've shown
            let shownCount = 0;
            
            // Check if no container is available yet
            if (!window.gifContainers || window.gifContainers.length === 0) {
                console.log("No GIF containers available yet");
                return;
            }
            
            // Update visibility of GIF containers
            window.gifContainers.forEach(container => {
                const cluster = container.dataset.cluster;
                const index = parseInt(container.dataset.index);
                
                const shouldShow = selectedClusters.includes(cluster) && shownCount < maxGifs && gifsVisible;
                
                if (shouldShow) {
                    container.style.display = 'block';
                    shownCount++;
                    console.log(`Showing GIF ${container.dataset.id} (cluster ${cluster})`);
                } else {
                    container.style.display = 'none';
                    console.log(`Hiding GIF ${container.dataset.id} (cluster ${cluster}, ${selectedClusters.includes(cluster) ? 'selected' : 'not selected'}, count: ${shownCount}/${maxGifs})`);
                }
            });
            
            console.log(`Showing ${shownCount} GIFs out of ${window.gifContainers.length}`);
        }
        
        // Make an element draggable
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            
            element.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Add dragging class
                element.classList.add('dragging');
                isDragging = false; // Reset dragging flag
                
                // Bring the element to the front
                element.style.zIndex = "1000";
                
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                
                // Set dragging flag when the mouse moves
                isDragging = true;
                
                // Calculate the new cursor position
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Set the element's new position
                const newTop = (element.offsetTop - pos2);
                const newLeft = (element.offsetLeft - pos1);
                
                // Constrain to plot boundaries
                const elemWidth = parseInt(element.style.width);
                const elemHeight = parseInt(element.style.height);
                
                const boundedTop = Math.max(elemHeight/2, Math.min(newTop, plotHeight - elemHeight/2));
                const boundedLeft = Math.max(elemWidth/2, Math.min(newLeft, plotWidth - elemWidth/2));
                
                element.style.top = boundedTop + "px";
                element.style.left = boundedLeft + "px";
            }
            
            function closeDragElement() {
                // Stop moving when mouse button is released
                document.onmouseup = null;
                document.onmousemove = null;
                
                // If was actually dragging, add a data attribute to prevent click event
                if (isDragging) {
                    element.dataset.wasDragging = 'true';
                    setTimeout(() => {
                        delete element.dataset.wasDragging;
                    }, 100);
                }
                
                // Remove dragging class
                element.classList.remove('dragging');
                
                // Reset z-index to normal
                setTimeout(() => {
                    element.style.zIndex = "10";
                }, 200);
            }
            
            // Add a click handler to override the default click if was dragging
            element.addEventListener('click', (e) => {
                if (element.dataset.wasDragging === 'true') {
                    e.stopPropagation(); // Prevent the click event from bubbling up
                }
            }, true); // Use capture phase
        }
        
        // Initialize the visualization
        function init() {
            // Add background points
            addBackgroundPoints();
            
            // Add GIFs
            addGifs();
            
            // Set up toggle button
            const toggleButton = document.getElementById('toggle-gifs');
            
            toggleButton.addEventListener('click', () => {
                gifsVisible = !gifsVisible; // Toggle state
                console.log(`Toggle GIFs visibility to: ${gifsVisible}`);
                
                // Update button text to indicate current action
                toggleButton.textContent = gifsVisible ? 'Hide GIFs' : 'Show GIFs';
                
                // Apply visibility to all containers
                window.gifContainers.forEach(container => {
                    console.log(`Updating container ${container.dataset.id} visibility to: ${gifsVisible ? 'block' : 'none'}`);
                    container.style.display = gifsVisible ? 'block' : 'none';
                });
            });
            
            // Set up resize functionality
            const sizeSlider = document.getElementById('gif-size-slider');
            const sizeValue = document.getElementById('size-value');
            
            sizeSlider.addEventListener('input', () => {
                const size = sizeSlider.value;
                sizeValue.textContent = size + 'px';
            });
            
            // Set up resize button
            const resizeButton = document.getElementById('resize-gifs');
            resizeButton.addEventListener('click', () => {
                const size = sizeSlider.value;
                
                window.gifContainers.forEach(container => {
                    container.style.width = size + 'px';
                    container.style.height = size + 'px';
                });
            });
            
            // Set up number of GIFs slider
            const numGifsSlider = document.getElementById('num-gifs-slider');
            const numGifsValue = document.getElementById('num-gifs-value');
            
            numGifsSlider.addEventListener('input', () => {
                const num = numGifsSlider.value;
                numGifsValue.textContent = num;
            });
            
            // Set up apply number of GIFs button
            const applyNumGifsButton = document.getElementById('apply-num-gifs');
            applyNumGifsButton.addEventListener('click', updateVisibleGifs);
            
            // Set up reset positions button
            const resetButton = document.getElementById('reset-positions');
            resetButton.addEventListener('click', () => {
                window.gifContainers.forEach(container => {
                    const id = container.id.replace('gif-', '');
                    // Use safe property access with proper syntax
                    if (originalPositions[id]) {
                        const pos = originalPositions[id];
                        container.style.left = `${pos.x}px`;
                        container.style.top = `${pos.y}px`;
                    }
                });
            });
            
            // Setup frame slider
            const frameSlider = document.getElementById('frame-slider');
            const frameValue = document.getElementById('frame-value');
            
            // Find the maximum number of frames across all GIFs
            let maxFrames = 80; // Default value
            Object.values(allFramesData).forEach(frames => {
                if (frames && frames.length > maxFrames) {
                    maxFrames = frames.length;
                }
            });
            
            // Set the slider max value
            frameSlider.max = maxFrames - 1;
            
            frameSlider.addEventListener('input', () => {
                // Update the displayed value
                currentFrame = parseInt(frameSlider.value);
                frameValue.textContent = currentFrame;
                
                // Pause any animation that's playing
                if (isPlaying) {
                    pauseFrames();
                    isPlaying = false;
                }
                
                // Update all GIFs to display the selected frame
                updateFrameDisplay(currentFrame);
            });
            
            // Setup play/pause button
            const playPauseButton = document.getElementById('play-pause');
            playPauseButton.addEventListener('click', () => {
                isPlaying = !isPlaying;
                
                if (isPlaying) {
                    playFrames();
                    playPauseButton.textContent = 'Pause';
                } else {
                    pauseFrames();
                    playPauseButton.textContent = 'Play';
                }
            });
            
            // Add event listener for the show max cleft button
            document.getElementById('show-max-cleft').addEventListener('click', showMaxCleftSlices);
            
            // Initial update of visible GIFs
            updateVisibleGifs();
            
            console.log("Initialization complete. GIFs visible:", gifsVisible);
            console.log("Total GIF containers:", window.gifContainers.length);
        }
        
        // Run initialization
        window.onload = init;
    </script>
</body>
</html>
